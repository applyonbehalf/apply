# quick_fix_and_test.py - Fixed version with proper paths and selenium check
import requests
import json
import time
import threading
import subprocess
import os
import sys

API_BASE = "http://localhost:8003"  # Changed port to avoid conflict
JOB_URL = "https://aqueity.applytojob.com/apply/Appyvb1yAu/Jr-SOC-Engineer?source=LinkedIn"

# Your user data
USER_DATA = {
    "email": "shubhmmane56@gmail.com",  # Fixed email
    "name": "Shubham Mane",
    "password": "secure_password_123"
}

def check_requirements():
    """Check if all requirements are met"""
    print("üîç Checking requirements...")
    
    # Check if backend exists
    if not os.path.exists('backend'):
        print("‚ùå Error: 'backend' directory not found.")
        return False
    
    # Check if profile.json exists
    absolute_profile_path = "/Users/shubhammane/Desktop/IntelliApply_Bot/data/profile.json"
    profile_paths = [absolute_profile_path, 'data/profile.json', 'profile.json']
    profile_found = False
    
    for path in profile_paths:
        if os.path.exists(path):
            print(f"‚úÖ Found profile.json at: {path}")
            profile_found = True
            break
    
    if not profile_found:
        print("‚ùå Error: profile.json not found")
        print("Searched in:", profile_paths)
        return False
    
    # Check if required packages are installed
    try:
        import selenium
        print("‚úÖ Selenium is available")
    except ImportError:
        print("‚ùå Selenium not installed. Installing...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "selenium", "webdriver-manager"])
            print("‚úÖ Selenium installed successfully")
        except subprocess.CalledProcessError:
            print("‚ùå Failed to install selenium")
            return False
    
    # Check for Google AI
    try:
        import google.generativeai
        print("‚úÖ Google AI is available")
    except ImportError:
        print("‚ùå Google AI not installed. Installing...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "google-generativeai"])
            print("‚úÖ Google AI installed successfully")
        except subprocess.CalledProcessError:
            print("‚ùå Failed to install Google AI")
            return False
    
    return True

def start_server():
    """Start the FastAPI server"""
    os.chdir('backend')
    subprocess.run(['python', '-m', 'uvicorn', 'main:app', '--host', '0.0.0.0', '--port', '8003'])

def load_profile_data():
    """Load profile data from multiple possible locations"""
    # Use absolute path first
    absolute_path = "/Users/shubhammane/Desktop/IntelliApply_Bot/data/profile.json"
    possible_paths = [
        absolute_path,
        'data/profile.json', 
        'profile.json', 
        './data/profile.json',
        './profile.json',
        os.path.expanduser('~/Desktop/IntelliApply_Bot/data/profile.json')
    ]
    
    print(f"üîç Looking for profile.json in:")
    for path in possible_paths:
        print(f"   - {path}")
        try:
            with open(path, 'r') as f:
                print(f"‚úÖ Loaded profile data from: {path}")
                return json.load(f)
        except FileNotFoundError:
            print(f"   ‚ùå Not found: {path}")
            continue
        except Exception as e:
            print(f"   ‚ùå Error reading {path}: {e}")
            continue
    
    print("‚ùå Could not find profile.json in any location")
    return None

def setup_user_and_profile():
    """Complete user setup process"""
    print("üîê Setting up user account and profile...")
    
    # Load your profile data
    profile_data = load_profile_data()
    if not profile_data:
        return None, None
    
    # Step 1: Try to register user (or login if already exists)
    print("1. Registering/logging in user...")
    try:
        response = requests.post(f"{API_BASE}/api/auth/register", json=USER_DATA, timeout=10)
        if response.status_code == 200:
            token_data = response.json()
            access_token = token_data["access_token"]
            print("‚úÖ User registered successfully")
        else:
            # Try login instead
            login_data = {"email": USER_DATA["email"], "password": USER_DATA["password"]}
            response = requests.post(f"{API_BASE}/api/auth/login", json=login_data, timeout=10)
            if response.status_code == 200:
                token_data = response.json()
                access_token = token_data["access_token"]
                print("‚úÖ User logged in successfully")
            else:
                print(f"‚ùå Authentication failed: {response.status_code}")
                print(f"Response: {response.text}")
                return None, None
    except requests.exceptions.ConnectionError:
        print("‚ùå Cannot connect to server. Make sure the backend is running.")
        return None, None
    except Exception as e:
        print(f"‚ùå Authentication error: {e}")
        return None, None
    
    headers = {"Authorization": f"Bearer {access_token}"}
    
    # Step 2: Create profile with your data
    print("2. Creating profile with your data...")
    try:
        # Clean the profile data to ensure JSON serialization
        def clean_for_json(obj):
            if isinstance(obj, dict):
                return {key: clean_for_json(value) for key, value in obj.items()}
            elif isinstance(obj, list):
                return [clean_for_json(item) for item in obj]
            elif hasattr(obj, 'isoformat'):  # datetime objects
                return obj.isoformat()
            else:
                return obj
        
        cleaned_profile_data = clean_for_json(profile_data)
        
        profile_request = {
            "profile_name": f"Cybersecurity Professional - {int(time.time())}",  # Unique name
            "profile_data": cleaned_profile_data,
            "is_default": False  # Always false to avoid constraint issues
        }
        
        response = requests.post(f"{API_BASE}/api/profiles", json=profile_request, headers=headers, timeout=15)
        if response.status_code == 200:
            profile = response.json()
            profile_id = profile['id']
            print(f"‚úÖ Profile created: {profile['profile_name']}")
            return access_token, profile_id
        else:
            print(f"‚ùå Profile creation failed: {response.status_code}")
            print(f"Response: {response.text}")
            
            # Try to get existing profile instead
            print("üîÑ Trying to use existing profile...")
            profiles_response = requests.get(f"{API_BASE}/api/profiles", headers=headers, timeout=10)
            if profiles_response.status_code == 200:
                profiles = profiles_response.json()
                if profiles:
                    profile_id = profiles[0]['id']
                    print(f"‚úÖ Using existing profile: {profiles[0]['profile_name']}")
                    return access_token, profile_id
            
            return access_token, None
            
    except Exception as e:
        print(f"‚ùå Profile creation error: {e}")
        return access_token, None

def test_single_application_simple(access_token, profile_id):
    """Test single application using the simple method"""
    print("üéØ Testing single application processing...")
    
    headers = {"Authorization": f"Bearer {access_token}"}
    
    # First, start the bot if it's not running
    print("1. Checking and starting bot...")
    try:
        # Check bot status
        response = requests.get(f"{API_BASE}/api/bot/status", headers=headers, timeout=10)
        if response.status_code == 200:
            status = response.json()['data']
            if not status.get('running', False):
                print("   Bot is not running. Starting bot...")
                
                # Start the bot
                bot_config = {"headless": False, "max_concurrent": 1}
                start_response = requests.post(f"{API_BASE}/api/bot/start", json=bot_config, headers=headers, timeout=15)
                if start_response.status_code == 200:
                    print("   ‚úÖ Bot started successfully")
                else:
                    print(f"   ‚ùå Failed to start bot: {start_response.status_code}")
                    print(f"   Response: {start_response.text}")
                    return False
            else:
                print("   ‚úÖ Bot is already running")
        else:
            print(f"   ‚ö†Ô∏è Could not check bot status: {response.status_code}")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Bot status check error: {e}")
    
    # Give bot a moment to initialize
    print("2. Waiting for bot to initialize...")
    time.sleep(3)
    
    try:
        # Use the simple single application endpoint
        single_app_request = {
            "profile_id": profile_id,
            "job_url": JOB_URL
        }
        
        print(f"3. Processing job application...")
        print(f"   URL: {JOB_URL}")
        print("   ‚ö†Ô∏è  This will open a browser window - do NOT close it!")
        print("   üö® If you see a CAPTCHA, solve it manually")
        
        response = requests.post(
            f"{API_BASE}/api/bot/process-single", 
            json=single_app_request, 
            headers=headers, 
            timeout=180  # 3 minutes timeout
        )
        
        if response.status_code == 200:
            result = response.json()
            if result.get('success'):
                print("üéâ Application processed successfully!")
                return True
            else:
                print(f"‚ùå Application failed: {result.get('message', 'Unknown error')}")
                return False
        else:
            print(f"‚ùå Request failed: {response.status_code}")
            print(f"Response: {response.text}")
            
            # If bot not running, try alternative approach
            if "Bot is not running" in response.text:
                print("\nüîÑ Bot not running, trying alternative approach...")
                return test_with_queue_method(access_token, profile_id, headers)
            
            return False
            
    except requests.exceptions.Timeout:
        print("‚è∞ Request timed out - this is normal for long processing")
        print("The application may still be processing in the background")
        print("Check the browser window to see if it completed")
        return False
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return False

def test_with_queue_method(access_token, profile_id, headers):
    """Alternative method using the queue system"""
    print("üìã Trying queue-based processing...")
    
    try:
        # Add to queue
        urls_request = {
            "profile_id": profile_id,
            "urls": [JOB_URL],
            "batch_name": "Test Application - Aqueity SOC"
        }
        
        response = requests.post(f"{API_BASE}/api/bot/add-urls", json=urls_request, headers=headers, timeout=10)
        if response.status_code == 200:
            result = response.json()
            print(f"   ‚úÖ Added to queue: {result['data']['applications_created']} applications")
            
            # Monitor for a short time
            print("   üìä Monitoring queue (30 seconds)...")
            for i in range(6):  # 6 * 5 = 30 seconds
                time.sleep(5)
                queue_response = requests.get(f"{API_BASE}/api/bot/my-queue", headers=headers, timeout=10)
                if queue_response.status_code == 200:
                    queue_info = queue_response.json()['data']
                    print(f"   Queue: {queue_info['processing']} processing, {queue_info['completed']} completed")
                    
                    if queue_info['completed'] > 0:
                        print("   üéâ Application completed via queue!")
                        return True
                    elif queue_info['failed'] > 0:
                        print("   ‚ùå Application failed in queue")
                        return False
            
            print("   ‚è∞ Queue monitoring timeout - check manually")
            return False
        else:
            print(f"   ‚ùå Failed to add to queue: {response.status_code}")
            return False
            
    except Exception as e:
        print(f"   ‚ùå Queue method error: {e}")
        return False

def main():
    """Main test function"""
    print("üöÄ IntelliApply Quick Fix and Test")
    print("=" * 50)
    
    # Check requirements first
    if not check_requirements():
        print("‚ùå Requirements check failed. Please fix the issues above.")
        return
    
    print("‚úÖ All requirements met!")
    
    # Start server
    print("\nüåê Starting backend server...")
    server_thread = threading.Thread(target=start_server, daemon=True)
    server_thread.start()
    
    # Wait for server to start
    print("‚è≥ Waiting for server to start...")
    time.sleep(8)
    
    # Test server connectivity
    try:
        response = requests.get(f"{API_BASE}/health", timeout=5)
        if response.status_code == 200:
            print("‚úÖ Server is running")
        else:
            print("‚ùå Server health check failed")
            return
    except Exception as e:
        print(f"‚ùå Cannot connect to server: {e}")
        return
    
    try:
        # Setup user and profile
        access_token, profile_id = setup_user_and_profile()
        
        if not access_token or not profile_id:
            print("‚ùå Failed to set up user and profile")
            return
        
        print(f"\n‚úÖ Setup complete!")
        print(f"   üîë Token: {access_token[:30]}...")
        print(f"   üë§ Profile ID: {profile_id}")
        
        # Ask user if they want to proceed
        print(f"\nüìã Ready to apply to:")
        print(f"   {JOB_URL}")
        print("\n‚ö†Ô∏è  This will:")
        print("   1. Open a browser window")
        print("   2. Navigate to the job page")
        print("   3. Fill out the application form automatically")
        print("   4. Submit the application")
        print("\nüö® IMPORTANT: If you see a CAPTCHA, solve it manually!")
        
        proceed = input("\n‚ùì Proceed with application? (y/n): ").lower().strip()
        
        if proceed == 'y' or proceed == 'yes':
            success = test_single_application_simple(access_token, profile_id)
            
            if success:
                print("\nüéâ SUCCESS! Check the job website to confirm your application.")
            else:
                print("\n‚ö†Ô∏è Application may have encountered issues.")
                print("Check the browser window for details.")
        else:
            print("üëç Test cancelled. Your account and profile are set up and ready!")
        
        print(f"\nüìä API Documentation: http://localhost:8003/docs")
        print("Press Ctrl+C to stop")
        
        # Keep server running
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nüëã Goodbye!")
            
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()